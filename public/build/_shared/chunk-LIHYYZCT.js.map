{
  "version": 3,
  "sources": ["../../../node_modules/remix-typedjson/dist/esm/remix.js", "../../../node_modules/remix-typedjson/dist/esm/typedjson.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Await, useActionData, useFetcher, useLoaderData, useMatches, } from '@remix-run/react';\nimport { defer } from '@remix-run/server-runtime';\nimport * as _typedjson from './typedjson';\nexport const typedjson = (data, init = {}) => {\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has('Content-Type')) {\n        headers.set('Content-Type', 'application/json; charset=utf-8');\n    }\n    return new Response(stringifyRemix(data), {\n        ...responseInit,\n        headers,\n    });\n};\nexport const typeddefer = (data, init = {}) => {\n    // wrap any Promises in the data with new Promises that will serialize the\n    // resolved data and add the meta to the response\n    Object.entries(data).forEach(([key, value]) => {\n        if (value instanceof Promise) {\n            ;\n            data[key] = value.then(resolvedData => {\n                const { meta } = _typedjson.serialize(resolvedData);\n                if (meta) {\n                    ;\n                    resolvedData['$$meta'] = meta;\n                }\n                return resolvedData;\n            });\n        }\n        else {\n            const { meta } = _typedjson.serialize(data);\n            if (meta) {\n                ;\n                data['$$meta'] = meta;\n            }\n        }\n    });\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    return defer(data, responseInit);\n};\nexport function TypedAwait(props) {\n    if (!props.children)\n        return null;\n    return (_jsx(Await, { ...props, children: data => {\n            if (data === null)\n                return null;\n            let deserializedData = deserializeRemix(data);\n            return props.children(deserializedData);\n        } }));\n}\nexport function useTypedLoaderData() {\n    const data = useLoaderData();\n    return deserializeRemix(data);\n}\nexport function useTypedActionData() {\n    const data = useActionData();\n    return deserializeRemix(data);\n}\nexport function useTypedFetcher(opts) {\n    const fetcher = useFetcher(opts);\n    if (fetcher.data) {\n        const newData = deserializeRemix(fetcher.data);\n        fetcher.data = newData ?? undefined;\n    }\n    return fetcher;\n}\nexport function useTypedRouteLoaderData(id) {\n    const match = useMatches().find(match => match.id === id);\n    if (!match)\n        return undefined;\n    return deserializeRemix(match.data);\n}\nexport function stringifyRemix(data) {\n    // prevent double JSON stringification\n    let { json, meta } = _typedjson.serialize(data);\n    if (json && meta) {\n        if (json.startsWith('{')) {\n            json = `${json.substring(0, json.length - 1)},\\\"$$meta\\\":${JSON.stringify(meta)}}`;\n        }\n        else if (json.startsWith('[')) {\n            json = `{\"$$obj\":${json},\"$$meta\":${JSON.stringify(meta)}}`;\n        }\n    }\n    return json;\n}\nexport function deserializeRemix(data) {\n    if (!data)\n        return data;\n    if (data.$$obj) {\n        // handle arrays wrapped in an object\n        return data.$$meta\n            ? _typedjson.applyMeta(data.$$obj, data.$$meta)\n            : data.$$obj;\n    }\n    else if (data.$$meta) {\n        // handle object with $$meta key\n        // remove before applying meta\n        const meta = data.$$meta;\n        delete data.$$meta;\n        return _typedjson.applyMeta(data, meta);\n    }\n    return data;\n}\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/api/remix#redirect\n */\nexport const redirect = (url, init = 302) => {\n    let responseInit = init;\n    if (typeof responseInit === 'number') {\n        responseInit = { status: responseInit };\n    }\n    else if (typeof responseInit.status === 'undefined') {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set('Location', url);\n    return new Response(null, {\n        ...responseInit,\n        headers,\n    });\n};\n", "let customTypeMap = new Map();\nexport function registerCustomType(entry) {\n    customTypeMap.set(entry.type, entry);\n}\nfunction serialize(data) {\n    if (data === null)\n        return { json: 'null' };\n    if (data === undefined)\n        return { json: undefined };\n    const stack = [];\n    const keys = [''];\n    const meta = new Map();\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    function replacer(key, value) {\n        function unwindStack() {\n            while (stack.length > 0) {\n                const top = stack[stack.length - 1];\n                if (top.iteration < top.count) {\n                    top.iteration++;\n                    return top;\n                }\n                if (top.type === 'object') {\n                    keys.pop();\n                }\n                stack.pop();\n            }\n        }\n        let entry = unwindStack();\n        if (entry) {\n            value = entry.value[key];\n        }\n        // handle dotted keys\n        if (key.includes('.')) {\n            key = `[${key}]`;\n        }\n        let metaKey = `${keys[keys.length - 1]}${key}`;\n        const valueType = typeof value;\n        if (valueType === 'object' && value !== null) {\n            let count = 0;\n            let t = 'undefined';\n            if (value instanceof Date) {\n                t = 'date';\n                value = value.toISOString();\n            }\n            else if (value instanceof Set) {\n                value = Array.from(value);\n                count = value.length;\n                t = 'set';\n            }\n            else if (value instanceof Map) {\n                value = Object.fromEntries(value);\n                count = Object.keys(value).length;\n                t = 'map';\n            }\n            else if (value instanceof Array) {\n                t = 'object';\n                count = value.length;\n            }\n            else if (value instanceof RegExp) {\n                t = 'regexp';\n                value = String(value);\n            }\n            else if (value instanceof Error) {\n                t = 'error';\n                value = { name: value.name, message: value.message, stack: value.stack };\n                // push error value to stack\n                stack.push({ type: 'object', value, count: 3, iteration: 0 });\n            }\n            else {\n                // check for custom types\n                let customType;\n                if (customTypeMapValues.length > 0) {\n                    customType = customTypeMapValues.find(entry => entry.is(value));\n                }\n                if (customType) {\n                    t = customType.type;\n                    value = customType.serialize(value);\n                }\n                else {\n                    count = Object.keys(value).length;\n                    t = 'object';\n                }\n            }\n            if (t !== 'object') {\n                meta.set(metaKey, t);\n            }\n            if (count !== 0) {\n                stack.push({ type: t, value, count, iteration: 0 });\n                if (key && t === 'object') {\n                    keys.push(`${metaKey}.`);\n                }\n                return value;\n            }\n        }\n        // handle non-object types\n        if (valueType === 'bigint') {\n            meta.set(metaKey, 'bigint');\n            return String(value);\n        }\n        if (valueType === 'number') {\n            if (value === Number.POSITIVE_INFINITY) {\n                meta.set(metaKey, 'infinity');\n                return 'Infinity';\n            }\n            if (value === Number.NEGATIVE_INFINITY) {\n                meta.set(metaKey, '-infinity');\n                return '-Infinity';\n            }\n            if (Number.isNaN(value)) {\n                meta.set(metaKey, 'nan');\n                return 'NaN';\n            }\n        }\n        if (typeof value === 'undefined') {\n            meta.set(metaKey, 'undefined');\n            return null;\n        }\n        return value;\n    }\n    const json = JSON.stringify(data, replacer);\n    return {\n        json,\n        meta: meta.size === 0 ? undefined : Object.fromEntries(meta.entries()),\n    };\n}\nfunction deserialize({ json, meta }) {\n    if (typeof json === 'undefined') {\n        return undefined;\n    }\n    if (!json)\n        return null;\n    const result = JSON.parse(json);\n    if (meta) {\n        applyMeta(result, meta);\n    }\n    return result;\n}\nexport const splitKey = (key) => {\n    // key is a dotted path\n    // may contain escaped dots which are keys wrapped in []\n    // example [b.c].d => ['b.c', 'd']\n    const keys = [];\n    const parts = key.split('.');\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i].startsWith('[')) {\n            let k = parts[i].substring(1);\n            let j = i + 1;\n            while (!parts[j].endsWith(']')) {\n                k += `.${parts[j]}`;\n                j++;\n            }\n            k += `.${parts[j].slice(0, -1)}`;\n            keys.push(k);\n            i = j;\n        }\n        else {\n            keys.push(parts[i]);\n        }\n    }\n    return keys;\n};\nfunction applyMeta(data, meta) {\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    for (const key of Object.keys(meta)) {\n        const keys = splitKey(key);\n        applyConversion(data, keys, meta[key]);\n    }\n    return data;\n    function applyConversion(data, keys, type, depth = 0) {\n        const key = keys[depth];\n        if (depth < keys.length - 1) {\n            applyConversion(data[key], keys, type, depth + 1);\n            return;\n        }\n        const value = data[key];\n        switch (type) {\n            case 'date':\n                data[key] = new Date(value);\n                break;\n            case 'set':\n                data[key] = new Set(value);\n                break;\n            case 'map':\n                data[key] = new Map(Object.entries(value));\n                break;\n            case 'regexp':\n                const match = /^\\/(.*)\\/([dgimsuy]*)$/.exec(value);\n                if (match) {\n                    data[key] = new RegExp(match[1], match[2]);\n                }\n                else {\n                    throw new Error(`Invalid regexp: ${value}`);\n                }\n                break;\n            case 'bigint':\n                data[key] = BigInt(value);\n                break;\n            case 'undefined':\n                data[key] = undefined;\n                break;\n            case 'infinity':\n                data[key] = Number.POSITIVE_INFINITY;\n                break;\n            case '-infinity':\n                data[key] = Number.NEGATIVE_INFINITY;\n                break;\n            case 'nan':\n                data[key] = NaN;\n                break;\n            case 'error':\n                const err = new Error(value.message);\n                err.name = value.name;\n                err.stack = value.stack;\n                data[key] = err;\n                break;\n            default:\n                // custom types\n                let customType = customTypeMap.get(type);\n                if (customType) {\n                    data[key] = customType.deserialize(value);\n                }\n        }\n    }\n}\nfunction stringify(data, replacer, space) {\n    if (replacer || space) {\n        const { json, meta } = serialize(data);\n        const jsonObj = deserialize({ json });\n        return JSON.stringify({\n            json: jsonObj,\n            meta,\n        }, replacer, space);\n    }\n    return JSON.stringify(serialize(data));\n}\nfunction parse(json) {\n    const result = JSON.parse(json);\n    return result ? deserialize(result) : null;\n}\nconst typedjson = {\n    serialize,\n    stringify,\n    deserialize,\n    parse,\n    applyMeta,\n};\nexport { applyMeta, deserialize, parse, serialize, stringify };\nexport default typedjson;\n"],
  "mappings": "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",
  "names": ["data"]
}
